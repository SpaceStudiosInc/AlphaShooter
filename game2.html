<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Bomber</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #000;
    color: #fff;
    font-family: system-ui, monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  #gameContainer {
    width: 100%;
    max-width: 900px;
    aspect-ratio: 16 / 9;
    position: relative;
    border: 6px solid #fff;
    background: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    background: #fff;
    touch-action: none;
  }
  #hud {
    position: absolute;
    left: 10px;
    top: 10px;
    color: #000;
    font-weight: 700;
    font-size: 14px;
    pointer-events: none;
  }
  #hud .line {
    margin-bottom: 4px;
  }
  #overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.9);
    z-index: 10;
  }
  .panel {
    background: #fff;
    color: #000;
    border: 3px solid #000;
    padding: 20px;
    text-align: center;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  button {
    padding: 10px 16px;
    font-weight: 700;
    border: 2px solid #000;
    background: #fff;
    color: #000;
    cursor: pointer;
    font-size: 16px;
    margin: 5px;
    touch-action: manipulation;
  }
  button:hover, button:active {
    background: #000;
    color: #fff;
  }
  #touchControls {
    position: absolute;
    bottom: 15px;
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    pointer-events: none;
    padding: 0 20px;
    box-sizing: border-box;
  }
  .touch-btn {
    background: rgba(0,0,0,0.7);
    color: #fff;
    border: 3px solid #fff;
    border-radius: 50%;
    width: 68px;
    height: 68px;
    font-size: 28px;
    text-align: center;
    line-height: 68px;
    pointer-events: auto;
    user-select: none;
    touch-action: manipulation;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  .touch-btn:active {
    background: rgba(255,255,255,0.9);
    color: #000;
    transform: scale(0.95);
  }
  @media (min-width: 769px) {
    #touchControls { display: none; }
  }
  /* Fix iOS full-screen bounce */
  body { position: fixed; }
</style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="c"></canvas>
    <div id="hud">
      <div class="line" id="scoreLabel">SCORE: 0</div>
      <div class="line" id="livesLabel">LIVES: 3</div>
      <div class="line" id="infoLabel">SPACE: SHOOT ‚Ä¢ Z: BOMB ‚Ä¢ P: PAUSE</div>
    </div>
    <div id="overlay" style="display:none">
      <div class="panel">
        <div id="overlayTitle" style="font-size:22px;margin-bottom:10px;">PAUSED</div>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
          <button id="resumeBtn">Resume</button>
          <button id="restartBtn">Restart</button>
        </div>
      </div>
    </div>
    <div id="touchControls">
      <div class="touch-btn" id="leftBtn">‚Üê</div>
      <div class="touch-btn" id="shootBtn">‚éµ</div>
      <div class="touch-btn" id="rightBtn">‚Üí</div>
      <div class="touch-btn" id="bombBtn">üí£</div>
    </div>
  </div>

<script>
'use strict';

// Prevent zoom on double-tap
let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
  const now = (new Date()).getTime();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, false);

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const W = () => canvas.width / (window.devicePixelRatio || 1);
const H = () => canvas.height / (window.devicePixelRatio || 1);

let paused = false, score = 0, lives = 3, level = 1, tick = 0;
const player = { 
  x: 0, y: 0, w: 34, h: 24, speed: 210, 
  bullets: [], bombs: [], 
  fireRate: 0.3, bombRate: 0.8, 
  fireTimer: 0, bombTimer: 0 
};

function resetPlayer(){ 
  player.x = W()/2 - player.w/2; 
  player.y = H() - player.h - 120; 
}
resetPlayer();

let enemies = [];
function spawnWave(){
  const count = Math.min(8 + level * 1.5, 18);
  enemies = [];
  for(let i = 0; i < count; i++){
    enemies.push({
      x: 30 + Math.random() * (W() - 60),
      y: -100 - i * 50 - Math.random() * 200,
      w: 20, h: 20,
      vx: (Math.random() > 0.5 ? 1 : -1) * (15 + Math.random() * 25),
      vy: 40 + Math.random() * 50 + level * 5,
      hp: 1 + (level > 5 ? 1 : 0),
      osc: Math.random() * 1.5,
      dead: false
    });
  }
}
spawnWave();

const keys = {};
window.addEventListener('keydown', e => {
  if(e.key === 'p' || e.key === 'P'){ togglePause(); return; }
  keys[e.key] = true;
  if([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'z', 'Z'].includes(e.key)) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => keys[e.key] = false);

const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
document.getElementById('resumeBtn').onclick = () => togglePause(false);
document.getElementById('restartBtn').onclick = restart;

function togglePause(force){
  paused = typeof force === 'boolean' ? force : !paused;
  overlay.style.display = paused ? 'flex' : 'none';
  overlayTitle.textContent = paused ? (lives <= 0 ? 'GAME OVER' : 'PAUSED') : '';
}
function restart(){
  score = 0; lives = 3; level = 1; tick = 0;
  enemies = []; player.bullets = []; player.bombs = [];
  resetPlayer(); spawnWave();
  paused = false; overlay.style.display = 'none';
}

function fireBullet(){
  if(player.fireTimer > 0) return;
  player.fireTimer = player.fireRate;
  player.bullets.push({ 
    x: player.x + player.w/2 - 2, 
    y: player.y - 10, 
    w: 4, h: 10, 
    vy: -520 
  });
}
function fireBomb(){
  if(player.bombTimer > 0 || player.bombs.length >= 3) return;
  player.bombTimer = player.bombRate;
  player.bombs.push({ 
    x: player.x + player.w/2 - 6, 
    y: player.y - 10, 
    w: 12, h: 14, 
    vy: -240, 
    exploding: false, t: 0, r: 0 
  });
}

function rectsOverlap(a, b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now;
  if(!paused){ update(dt); draw(); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(dt){
  tick += dt;
  player.fireTimer = Math.max(0, player.fireTimer - dt);
  player.bombTimer = Math.max(0, player.bombTimer - dt);

  let mx = 0;
  if(keys['ArrowLeft'] || keys['a']) mx--;
  if(keys['ArrowRight'] || keys['d']) mx++;
  if(mx !== 0){
    player.x += mx * player.speed * dt;
  }
  player.x = Math.max(8, Math.min(W() - player.w - 8, player.x));

  if(keys[' '] || keys['Space']) fireBullet();
  if(keys['z'] || keys['Z']) fireBomb();

  // Bullets
  for(let b of player.bullets){
    b.y += b.vy * dt;
  }
  player.bullets = player.bullets.filter(b => b.y > -20);

  // Bombs
  for(let b of player.bombs){
    if(!b.exploding){
      b.y += b.vy * dt;
      for(let e of enemies){
        if(rectsOverlap(b, e)){
          b.exploding = true; b.vy = 0; b.t = 0; b.r = 0;
          break;
        }
      }
    } else {
      b.t += dt;
      b.r = Math.min(90, b.r + 300 * dt);
      if(b.t > 0.1){
        for(let e of enemies){
          const dx = (e.x + e.w/2) - (b.x + b.w/2);
          const dy = (e.y + e.h/2) - (b.y + b.h/2);
          if(Math.hypot(dx, dy) <= b.r){
            e.hp--;
            if(e.hp <= 0) { e.dead = true; score += 100; }
          }
        }
      }
    }
  }
  player.bombs = player.bombs.filter(b => !b.exploding || b.t < 0.4);

  // Enemies
  for(let e of enemies){
    e.y += e.vy * dt;
    e.x += Math.sin(tick * 3 + e.osc) * e.vx * dt * 0.8;
  }
  enemies = enemies.filter(e => !e.dead && e.y < H() + 50);

  // Bullet-enemy collision
  for(let b of player.bullets){
    for(let e of enemies){
      if(rectsOverlap(b, e)){
        e.hp--; b.dead = true;
        if(e.hp <= 0){ e.dead = true; score += 100; }
      }
    }
  }
  player.bullets = player.bullets.filter(b => !b.dead);

  // Player-enemy collision
  for(let e of enemies){
    if(rectsOverlap(player, e)){
      lives--;
      resetPlayer();
      e.dead = true;
      if(lives <= 0) gameOver();
    }
  }
  enemies = enemies.filter(e => !e.dead);

  if(enemies.length === 0){
    level++;
    spawnWave();
  }

  document.getElementById('scoreLabel').textContent = `SCORE: ${score}`;
  document.getElementById('livesLabel').textContent = `LIVES: ${lives}`;
}

function gameOver(){
  paused = true;
  overlay.style.display = 'flex';
  overlayTitle.textContent = 'GAME OVER';
  document.getElementById('resumeBtn').style.display = 'none';
  setTimeout(() => {
    document.getElementById('resumeBtn').style.display = 'inline-block';
  }, 100);
}

function draw(){
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W(), H());

  // Enemies
  for(let e of enemies){
    ctx.fillStyle = '#000';
    ctx.fillRect(e.x, e.y, e.w, e.h);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#fff';
    ctx.strokeRect(e.x, e.y, e.w, e.h);
  }

  // Bullets
  ctx.fillStyle = '#000';
  for(let b of player.bullets){
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  // Bombs
  for(let b of player.bombs){
    if(!b.exploding){
      ctx.fillStyle = '#000';
      ctx.fillRect(b.x, b.y, b.w, b.h);
    } else {
      ctx.beginPath();
      ctx.arc(b.x + b.w/2, b.y + b.h/2, b.r, 0, Math.PI * 2);
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#000';
      ctx.stroke();
    }
  }

  drawPlayerDrone();

  // Lives indicators
  for(let i = 0; i < lives; i++){
    drawMiniDrone(10 + i * 24, 36);
  }
}

function drawPlayerDrone(){
  const {x, y, w, h} = player;
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.fillRect(x, y, w, h);
  ctx.strokeRect(x, y, w, h);
  ctx.beginPath();
  ctx.arc(x + w/2, y + h/2, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();

  const props = [[x-6,y-6],[x+w+6,y-6],[x-6,y+h+6],[x+w+6,y+h+6]];
  for(let [px, py] of props) drawProp(px, py);
}
function drawProp(px, py){
  ctx.fillStyle = '#000';
  ctx.fillRect(px-5, py-1, 10, 2);
  ctx.fillRect(px-1, py-5, 2, 10);
}
function drawMiniDrone(x, y){
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  ctx.fillRect(x, y, 14, 8);
  ctx.strokeRect(x, y, 14, 8);
}

/* TOUCH CONTROLS - IMPROVED */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const shootBtn = document.getElementById('shootBtn');
const bombBtn = document.getElementById('bombBtn');

function bindTouch(btn, pressKey, releaseKey = pressKey){
  btn.addEventListener('touchstart', e => {
    e.preventDefault();
    e.stopPropagation();
    keys[pressKey] = true;
  }, { passive: false });

  btn.addEventListener('touchend', e => {
    e.preventDefault();
    keys[releaseKey] = false;
  }, { passive: false });

  // Optional: mouse support for testing
  btn.addEventListener('mousedown', () => keys[pressKey] = true);
  btn.addEventListener('mouseup', () => keys[releaseKey] = false);
  btn.addEventListener('mouseleave', () => keys[releaseKey] = false);
}

bindTouch(leftBtn, 'ArrowLeft');
bindTouch(rightBtn, 'ArrowRight');
bindTouch(shootBtn, ' ');
bindTouch(bombBtn, 'z');

// Prevent context menu on long press
document.addEventListener('contextmenu', e => e.preventDefault());

</script>
</body>
</html>
