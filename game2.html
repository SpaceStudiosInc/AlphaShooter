
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bomber</title>
<style>
  :root{
    --bg:#000;
    --panel:#fff;
    --accent:#ffd700;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Roboto,monospace}
  #wrapper{display:flex;flex-direction:column;align-items:center;gap:8px;padding:12px;}
  #gameContainer{width:100%;max-width:900px;border:6px solid var(--panel);background:#000;position:relative}
  canvas{display:block;width:100%;height:640px;background:#000}
  #hud{position:absolute;left:10px;top:10px;color:#fff;pointer-events:none}
  #hud .line{margin-bottom:6px}
  #score{font-weight:700}
  #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto}
  .panel{background:var(--panel);color:#000;padding:18px;border:6px solid #000;text-align:center}
  button{cursor:pointer;padding:8px 14px;font-weight:700}
  #mobileControls{display:none;position:absolute;left:0;right:0;bottom:12px;justify-content:space-between;padding:0 18px;pointer-events:auto}
  .touchGroup{display:flex;gap:8px}
  .touchBtn{background:#fff;border:3px solid #000;padding:12px 18px;border-radius:8px;color:#000;font-weight:800;user-select:none}
  .touchBtn:active{transform:translateY(1px)}
  @media(max-width:720px){
    canvas{height:480px}
    #mobileControls{display:flex}
  }
  /* small neat border around canvas content */
  .border-guide{position:absolute;inset:0;pointer-events:none;border:4px dashed rgba(255,255,255,0.02)}
</style>
</head>
<body>
  <div id="wrapper">
    <h2 style="color:#fff;margin:0"></h2>
    <div id="gameContainer">
      <canvas id="c"></canvas>

      <!-- HUD -->
      <div id="hud">
        <div class="line" id="scoreLabel">SCORE: 0</div>
        <div class="line" id="livesLabel">LIVES: 3</div>
        <div class="line" id="infoLabel">SHOOT: SPACE • BOMB: Z • PAUSE: P</div>
      </div>

      <!-- Overlay UI (pause / game over) -->
      <div id="overlay" style="display:none">
        <div class="panel" id="overlayPanel">
          <div id="overlayTitle" style="font-size:22px;margin-bottom:10px">PAUSED</div>
          <div style="display:flex;gap:12px;justify-content:center">
            <button id="resumeBtn">Resume</button>
            <button id="restartBtn">Restart</button>
          </div>
        </div>
      </div>

      <!-- Mobile controls (left/right/up/down, shoot, bomb) -->
      <div id="mobileControls" style="display:none">
        <div class="touchGroup">
          <div class="touchBtn" id="btnLeft">◀</div>
          <div class="touchBtn" id="btnUp">▲</div>
          <div class="touchBtn" id="btnDown">▼</div>
          <div class="touchBtn" id="btnRight">▶</div>
        </div>
        <div class="touchGroup">
          <div class="touchBtn" id="btnShoot">SHOOT</div>
          <div class="touchBtn" id="btnBomb">BOMB</div>
        </div>
      </div>

      <div class="border-guide"></div>
    </div>
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.max(640, Math.floor(rect.width * devicePixelRatio));
  canvas.height = Math.floor(rect.height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const W = () => canvas.width / devicePixelRatio;
const H = () => canvas.height / devicePixelRatio;

// --- Game State ---
let running = true;
let paused = false;
let score = 0;
let lives = 3;
let level = 1;
let tick = 0;

// --- Player ---
const player = {
  x: 0, y: 0, w: 34, h: 24,
  speed: 210,
  bullets: [],
  bombs: [],
  fireRate: 0.3,
  bombRate: 1,5,
  fireTimer: 0,
  bombTimer: 0
};
function resetPlayerPosition(){
  player.x = Math.round(W()/2 - player.w/2);
  player.y = Math.round(H() - player.h - 120);
}
resetPlayerPosition();

// --- Enemies ---
let enemies = [];
function spawnWave(){
  const count = Math.min(8 + level, 16);
  for(let i=0;i<count;i++){
    enemies.push({
      x: Math.random()*(W()-60)+30,
      y: -Math.random()*H()-i*40,
      w: 20, h: 20,
      vx: (Math.random()>0.5?1:-1)*(10+Math.random()*20),
      vy: 40 + Math.random()*40 + level*4,
      hp: 1,
      oscillation: Math.random()*1.2
    });
  }
}
spawnWave();

function rectsOverlap(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

// --- Background (grass field with variation) ---
const grassPatternCanvas = document.createElement('canvas');
grassPatternCanvas.width = 128;
grassPatternCanvas.height = 128;
const gctx = grassPatternCanvas.getContext('2d');
for(let y=0;y<128;y++){
  for(let x=0;x<128;x++){
    const g = 40 + Math.floor(Math.random()*80);
    gctx.fillStyle = `rgb(${g},${100+Math.random()*80|0},${40+Math.random()*40|0})`;
    gctx.fillRect(x,y,1,1);
  }
}
const grassPattern = ctx.createPattern(grassPatternCanvas, 'repeat');

// --- Input ---
const keys = {};
window.addEventListener('keydown', e => {
  if(e.key==='p' || e.key==='P'){ togglePause(); return; }
  keys[e.key] = true;
  if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
});
window.addEventListener('keyup', e => keys[e.key]=false);

// --- UI ---
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
document.getElementById('resumeBtn').addEventListener('click', ()=>togglePause(false));
document.getElementById('restartBtn').addEventListener('click', restartGame);

function togglePause(forcePause){
  paused = typeof forcePause==='boolean' ? forcePause : !paused;
  overlay.style.display = paused ? 'flex' : 'none';
  overlayTitle.textContent = paused ? 'PAUSED' : 'RESUME';
}
function restartGame(){
  score=0; lives=3; level=1; tick=0;
  enemies=[]; player.bullets=[]; player.bombs=[];
  resetPlayerPosition(); spawnWave();
  paused=false; overlay.style.display='none';
}

// --- Shooting ---
function fireBullet(){
  if(player.fireTimer>0) return;
  player.fireTimer = player.fireRate;
  player.bullets.push({
    x: player.x + player.w/2 - 2,
    y: player.y - 10,
    w: 4, h: 10,
    vy: -460, dmg: 1
  });
}
function fireBombForward(){
  if(player.bombTimer>0) return;
  player.bombTimer = player.bombRate;
  player.bombs.push({
    x: player.x + player.w/2 - 6,
    y: player.y - 10,
    w: 12, h: 14,
    vy: -220,
    exploding: false,
    timer: 0,
    exRadius: 0
  });
}

// --- Game Loop ---
let lastTime = performance.now();
function gameLoop(now){
  if(!running) return;
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;
  if(!paused){ update(dt); draw(); }
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

function update(dt){
  tick += dt;
  player.fireTimer = Math.max(0, player.fireTimer - dt);
  player.bombTimer = Math.max(0, player.bombTimer - dt);

  // Movement
  const move = {x:0,y:0};
  if(keys['ArrowLeft']) move.x -= 1;
  if(keys['ArrowRight']) move.x += 1;
  if(keys['ArrowUp']) move.y -= 1;
  if(keys['ArrowDown']) move.y += 1;
  const len = Math.hypot(move.x,move.y);
  if(len>0){
    player.x += (move.x/len)*player.speed*dt;
    player.y += (move.y/len)*player.speed*dt;
  }
  player.x = Math.max(8, Math.min(W()-player.w-8, player.x));
  player.y = Math.max(8, Math.min(H()-player.h-8, player.y));

  if(keys[' '] || keys['Spacebar'] || keys['Space']) fireBullet();
  if(keys['z'] || keys['Z']) fireBombForward();

  // Bullets
  for(let i=player.bullets.length-1;i>=0;i--){
    const b=player.bullets[i];
    b.y += b.vy*dt;
    if(b.y + b.h < -20) player.bullets.splice(i,1);
  }

  // Bombs (now forward missile with splash)
  for(let i=player.bombs.length-1;i>=0;i--){
    const b=player.bombs[i];
    b.y += b.vy*dt;
    if(!b.exploding){
      // check collision with enemies
      for(let e of enemies){
        if(rectsOverlap(b,e)){
          b.exploding=true; b.vy=0; b.exRadius=0; break;
        }
      }
      if(b.y < -20) player.bombs.splice(i,1);
    } else {
      b.timer+=dt;
      b.exRadius = Math.min(80, b.exRadius + 240*dt);
      if(b.timer>0.15){
        for(let e of enemies){
          const dx=(e.x+e.w/2)-(b.x+b.w/2);
          const dy=(e.y+e.h/2)-(b.y+b.h/2);
          const d=Math.hypot(dx,dy);
          if(d<=b.exRadius){ e.hp-=1; if(e.hp<=0){ score+=100; e.dead=true; } }
        }
      }
      if(b.timer>0.35) player.bombs.splice(i,1);
    }
  }

  // Enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    e.y += e.vy*dt;
    e.x += Math.sin(tick*2 + e.oscillation) * e.vx * dt * 0.7;
    if(e.dead || e.y>H()+40) enemies.splice(i,1);
  }

  // Bullet collisions
  for(let bi=player.bullets.length-1;bi>=0;bi--){
    const b=player.bullets[bi];
    for(let ei=enemies.length-1;ei>=0;ei--){
      const e=enemies[ei];
      if(rectsOverlap(b,e)){
        player.bullets.splice(bi,1);
        e.hp-=b.dmg;
        if(e.hp<=0){ score+=100; enemies.splice(ei,1); }
        break;
      }
    }
  }

  // Enemy collisions with player
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    if(rectsOverlap(player,e)){
      enemies.splice(i,1);
      playerHit();
    }
  }

  // Respawn waves
  if(enemies.length===0){ level++; spawnWave(); }

  document.getElementById('scoreLabel').textContent = `SCORE: ${score}`;
  document.getElementById('livesLabel').textContent = `LIVES: ${lives}`;
}

function playerHit(){
  lives--;
  resetPlayerPosition();
  if(lives<=0) gameOver();
}

function gameOver(){
  paused=true;
  overlay.style.display='flex';
  overlayTitle.textContent='GAME OVER';
}

// --- DRAW ---
function draw(){
  // background grass
  ctx.fillStyle = grassPattern;
  ctx.fillRect(0,0,W(),H());

  // slight parallax dark bands
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for(let i=0;i<H();i+=40){ ctx.fillRect(0,i,W(),2); }

  // enemies (people heads)
  for(let e of enemies){
    ctx.save();
    ctx.translate(e.x+e.w/2, e.y+e.h/2);
    // shadow
    ctx.beginPath();
    ctx.fillStyle='rgba(0,0,0,0.2)';
    ctx.arc(2,2,10,0,Math.PI*2);
    ctx.fill();
    // body
    ctx.beginPath();
    ctx.fillStyle='#664422';
    ctx.arc(0,0,8,0,Math.PI*2);
    ctx.fill();
    // head highlight
    ctx.beginPath();
    ctx.fillStyle='#ffcc99';
    ctx.arc(0,-3,4,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // bullets
  ctx.fillStyle='#aaf';
  for(let b of player.bullets) ctx.fillRect(b.x,b.y,b.w,b.h);

  // bombs / forward missiles
  for(let b of player.bombs){
    if(!b.exploding){
      ctx.fillStyle='#ffcc44';
      ctx.fillRect(b.x,b.y,b.w,b.h);
    } else {
      ctx.beginPath();
      ctx.fillStyle='rgba(255,140,0,0.8)';
      ctx.arc(b.x+b.w/2,b.y+b.h/2,b.exRadius,0,Math.PI*2);
      ctx.fill();
    }
  }

  // player drone
  drawPlayerDrone();

  // lives
  for(let i=0;i<lives;i++){
    const px=10+i*26, py=36;
    drawSmallShip(px,py);
  }
}

function drawPlayerDrone(){
  const x=player.x, y=player.y, w=player.w, h=player.h;
  ctx.fillStyle='#cceeff';
  roundRect(ctx,x,y,w,h,10,true,false);
  ctx.fillStyle='#222';
  ctx.beginPath(); ctx.arc(x+w/2,y+h+4,4,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#555'; ctx.lineWidth=1; ctx.stroke();
  ctx.strokeStyle='#888'; ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(x+6,y+4); ctx.lineTo(x-10,y-10);
  ctx.moveTo(x+w-6,y+4); ctx.lineTo(x+w+10,y-10);
  ctx.moveTo(x+6,y+h-4); ctx.lineTo(x-10,y+h+10);
  ctx.moveTo(x+w-6,y+h-4); ctx.lineTo(x+w+10,y+h+10);
  ctx.stroke();
  ctx.fillStyle='#000';
  drawPropeller(x-12,y-12); drawPropeller(x+w+12,y-12);
  drawPropeller(x-12,y+h+12); drawPropeller(x+w+12,y+h+12);
  ctx.fillStyle='#66aaff';
  ctx.beginPath(); ctx.arc(x+w/2,y+h/2-4,6,0,Math.PI*2); ctx.fill();
}
function drawPropeller(px,py){
  ctx.save(); ctx.translate(px,py);
  ctx.fillRect(-6,-1,12,2); ctx.fillRect(-1,-6,2,12);
  ctx.restore();
}
function drawSmallShip(x,y){
  ctx.fillStyle='#88ffdd';
  ctx.fillRect(x,y,16,8);
  ctx.fillStyle='#004466';
  ctx.fillRect(x+6,y+2,4,4);
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

function init(){ resetPlayerPosition(); lastTime=performance.now(); requestAnimationFrame(gameLoop); }
init();
</script>

</body>
</html>
